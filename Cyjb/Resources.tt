<#
/**
 * 为同名的 .resx 文件生成强类型代码。
 * 与 ResXFileCodeGenerator 相比，提供了字符串格式化能力。
 */
#>
<#@ template language="C#" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
	EnvDTE.DTE dte = (Host as IServiceProvider)?.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
	if (dte == null)
	{
		Error("当前 ResX 模板只能在 Visual Studio 环境下执行");
	}
	string resxPath = Host.TemplateFile.Replace(".tt", ".resx");
	EnvDTE.Project project = dte.Solution.FindProjectItem(resxPath).ContainingProject;
	if (project == null)
	{
		Error(resxPath + " 并未包含在任何项目中");
	}
	string projectPath = Path.GetDirectoryName(project.FileName);
	string resxClassName = Path.GetFileNameWithoutExtension(resxPath);
	string rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();
	string resxNamespace = rootNamespace + Path.GetDirectoryName(resxPath).Replace(projectPath, "").Replace("\\", ".");
	// 读取资源信息
	XmlDocument xml = new();
	xml.Load(resxPath);
	XmlNodeList resItems = xml.DocumentElement?.SelectNodes("//data");

	// 无效字符的正则表达式。
	Regex invalidChars = new("[^\\p{L}0-9]");
	// 格式项的正则表达式。
	Regex formatItemRegex = new(@"{(\d+)(?:,\d+)?(?::[^}]+)?}");

	/// <summary>
	/// 标准化指定的名称。
	/// </summary>
	string NormalizeName(string name)
	{
		StringBuilder text = new();
		foreach (string part in invalidChars.Replace(name, " ").Split(' '))
		{
			if (part.Length == 0)
			{
				continue;
			}
			text.Append(char.ToUpper(part[0]));
			text.Append(part, 1, part.Length - 1);
		}
		// 避免以数字开头。
		if (char.IsDigit(text[0]))
		{
			text.Insert(0, '_');
		}
		return text.ToString();
	}
#>
//------------------------------------------------------------------------------
// <auto-generated>
// 此代码由工具生成。
//
// 对此文件的更改可能会导致不正确的行为，并且如果
// 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= resxNamespace #>;

using CompilerServices = global::System.Runtime.CompilerServices;
using ComponentModel = global::System.ComponentModel;
using Diagnostics = global::System.Diagnostics;
using ResourceManager = global::System.Resources.ResourceManager;
using CultureInfo = global::System.Globalization.CultureInfo;

/// <summary>
/// 一个强类型的资源类，用于查找本地化的字符串等。
/// </summary>
/// <remarks>此类是由 T4 文本模板通过 Visual Studio 的工具自动生成的。
/// 若要添加或移除成员，请编辑 .ResX 文件，然后重新运行 T4 模板。
/// </remarks>
[Diagnostics.DebuggerNonUserCodeAttribute()]
[CompilerServices.CompilerGeneratedAttribute()]
internal partial class <#= resxClassName #>
{
	#nullable enable

	private static ResourceManager? resourceManager;
	private static CultureInfo? resourceCulture;

	/// <summary>
	/// 获取此类使用的缓存的 <see cref="ResourceManager"/> 实例。
	/// </summary>
	[ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Advanced)]
	internal static ResourceManager ResourceManager
	{
		get
		{
			if (resourceManager is null)
			{
				resourceManager = new ResourceManager("<#= resxNamespace #>.<#= resxClassName #>", typeof(<#= resxClassName #>).Assembly);
			}
			return resourceManager;
		}
	}

	/// <summary>
	/// 获取或设置资源使用的区域信息。
	/// </summary>
	[ComponentModel.EditorBrowsable(ComponentModel.EditorBrowsableState.Advanced)]
	internal static CultureInfo? Culture
	{
		get
		{
			return resourceCulture;
		}
		set
		{
			resourceCulture = value;
		}
	}
	<#
		foreach (XmlElement item in resItems)
		{
			string name = item.Attributes["name"].Value;
			XmlNode valueNode = item.SelectSingleNode("value");
			string value = string.Empty;
			if (valueNode != null)
			{
				value = valueNode.InnerText;
			}
			XmlNode commentNode = item.SelectSingleNode("comment");
			string comment = string.Empty;
			if (commentNode != null)
			{
				comment = commentNode.InnerText;
			}

			MatchCollection matches = formatItemRegex.Matches(value);
			if (matches.Count > 0) {
				// 计算格式索引的个数
				HashSet<string> indexes = new();
				foreach(Match match in matches)
				{
					indexes.Add(match.Groups[1].Value);
				}
				int argsCount = indexes.Count;
	#>

	/// <summary>
	/// 返回类似 <c><#= value #></c> 的本地化字符串。
	/// </summary>
	internal static string <#= NormalizeName(name) #>(<#
		for (int i = 0;i < argsCount;i++)
		{
			if (i > 0)
			{
				Write(", ");
			}
			Write("object? arg");
			Write(i.ToString());
		}
	#>)
	{
		return string.Format(resourceCulture, ResourceManager.GetString("<#= name #>", resourceCulture)!, <#
		for (int i = 0;i < argsCount;i++)
		{
			if (i > 0)
			{
				Write(", ");
			}
			Write("Format(arg");
			Write(i.ToString());
			Write(")");
		}
	#>);
	}
	<#
			} else {
	#>

	/// <summary>
	/// 返回类似 <c><#= value #></c> 的本地化字符串。
	/// </summary>
	internal static string <#= NormalizeName(name) #> => ResourceManager.GetString("<#= name #>", resourceCulture)!;
	<#
			}
		}
	#>

	/// <summary>
	/// 将指定对象格式化为字符串。
	/// </summary>
	/// <param name="value">要格式化的对象。</param>
	private static object Format(object? value)
	{
		if (value == null)
		{
			return "(null)";
		}
		return value;
	}

	#nullable restore

}

