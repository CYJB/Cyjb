<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AggregateExceptionDeserializationFailure" xml:space="preserve">
    <value>序列化流不包含内部异常。</value>
    <comment>异常集合反序列化异常。</comment>
  </data>
  <data name="AmbiguousMatchField" xml:space="preserve">
    <value>找到多个有指定名称且与指定绑定约束匹配的字段。</value>
    <comment>找到多个有指定名称且与指定绑定约束匹配的字段。</comment>
  </data>
  <data name="AmbiguousMatchMethod" xml:space="preserve">
    <value>找到多个有指定名称且与指定绑定约束匹配的方法。</value>
    <comment>找到多个有指定名称且与指定绑定约束匹配的方法。</comment>
  </data>
  <data name="AmbiguousMatchProperty" xml:space="preserve">
    <value>找到多个有指定名称且与指定绑定约束匹配的属性。</value>
    <comment>找到多个有指定名称且与指定绑定约束匹配的属性。</comment>
  </data>
  <data name="ArgumentImplementIComparable" xml:space="preserve">
    <value>必须至少有一个对象实现 IComparable。</value>
    <comment>必须至少有一个对象实现 IComparable。</comment>
  </data>
  <data name="ArgumentMustBePositive" xml:space="preserve">
    <value>参数值必须大于 0。</value>
    <comment>参数小于等于零。</comment>
  </data>
  <data name="ArgumentNegative" xml:space="preserve">
    <value>参数值不能为负。</value>
    <comment>参数小于零。</comment>
  </data>
  <data name="ArgumentOutOfRange" xml:space="preserve">
    <value>参数值超出了有效范围。</value>
    <comment>参数超出范围。</comment>
  </data>
  <data name="ArgumentOutOfRangeBetween" xml:space="preserve">
    <value>参数值必须位于 {1} 和 {2} 之间。</value>
    <comment>参数超出范围。</comment>
  </data>
  <data name="ArgumentWrongType" xml:space="preserve">
    <value>值 '{0}' 不是 '{1}' 类型。</value>
    <comment>值不是特定类型。</comment>
  </data>
  <data name="ArrayEmpty" xml:space="preserve">
    <value>数组不得为空。</value>
    <comment>数组为空。</comment>
  </data>
  <data name="ArrayNonZeroLowerBound" xml:space="preserve">
    <value>目标数组的下限必须为 0。</value>
    <comment>数组的下限必须为 0。</comment>
  </data>
  <data name="ArrayRankMultiDimNotSupported" xml:space="preserve">
    <value>只支持一维数组。</value>
    <comment>多维数组不被支持。</comment>
  </data>
  <data name="ArrayTooSmall" xml:space="preserve">
    <value>目标数组的长度不足，请检查数组索引和长度。</value>
    <comment>目标数组太小。</comment>
  </data>
  <data name="ArrayTypeInvalid" xml:space="preserve">
    <value>目标数组类型与集合中项的类型不兼容。</value>
    <comment>目标数组类型与集合中项的类型不兼容。</comment>
  </data>
  <data name="BaseConvertNegativeValue" xml:space="preserve">
    <value>如果基不为 10，则此字符串不能包含减号。</value>
    <comment>如果基不为 10，则此字符串不能包含减号。</comment>
  </data>
  <data name="BindTargetField" xml:space="preserve">
    <value>无法绑定到目标字段，因其类型或安全透明度与委托类型的签名或安全透明度不兼容。</value>
    <comment>绑定到目标字段时出错。</comment>
  </data>
  <data name="BindTargetMethod" xml:space="preserve">
    <value>无法绑定到目标方法，因其签名或安全透明度与委托类型的签名或安全透明度不兼容。</value>
    <comment>绑定到目标方法时出错。</comment>
  </data>
  <data name="BindTargetProperty" xml:space="preserve">
    <value>无法绑定到目标属性，因其签名或安全透明度与委托类型的签名或安全透明度不兼容。</value>
    <comment>绑定到目标属性时出错。</comment>
  </data>
  <data name="BindTargetPropertyNoGet" xml:space="preserve">
    <value>无法绑定到目标属性，因其不存在 get 访问器。</value>
    <comment>绑定到目标属性时出错。</comment>
  </data>
  <data name="BindTargetPropertyNoSet" xml:space="preserve">
    <value>无法绑定到目标属性，因其不存在 set 访问器。</value>
    <comment>绑定到目标属性时出错。</comment>
  </data>
  <data name="CannotCastNullToValueType" xml:space="preserve">
    <value>空对象不能转换为值类型。</value>
    <comment>空对象不能转换为值类型。</comment>
  </data>
  <data name="CannotInferGenericArguments" xml:space="preserve">
    <value>无法从参数中推导出方法 {0} 的类型实参。</value>
    <comment>无效的泛型参数推断。</comment>
  </data>
  <data name="ConvertInvalidValue" xml:space="preserve">
    <value>'{0}' 不是 '{1}' 的有效值。</value>
    <comment>转换无效。</comment>
  </data>
  <data name="EnumFailedVersion" xml:space="preserve">
    <value>集合已修改；可能无法执行枚举操作。</value>
    <comment>无法执行枚举操作。</comment>
  </data>
  <data name="EnumTypeDoesNotMatch" xml:space="preserve">
    <value>参数类型 '{0}' 与枚举类型 '{1}' 不相同。</value>
    <comment>枚举参数类型不匹配。</comment>
  </data>
  <data name="EnumValueNotFound" xml:space="preserve">
    <value>在枚举 '{0}‘ 中未找到请求的值 '{1}'。</value>
    <comment>未识别的枚举值。</comment>
  </data>
  <data name="ExtraJunkAtEnd" xml:space="preserve">
    <value>字符串的末尾有其他无法分析的字符。</value>
    <comment>字符串的末尾有其他无法分析的字符。</comment>
  </data>
  <data name="FixedSizeCollection" xml:space="preserve">
    <value>集合是固定大小的。</value>
    <comment>集合是固定大小的。</comment>
  </data>
  <data name="InnerExceptionNull" xml:space="preserve">
    <value>innerExceptions 的一个元素为 null。</value>
    <comment>内部异常之一为 null。</comment>
  </data>
  <data name="InvalidBase" xml:space="preserve">
    <value>基不在 2 至 36 之间。</value>
    <comment>无效的基。</comment>
  </data>
  <data name="InvalidCacheOption" xml:space="preserve">
    <value>无效的缓冲池选项 '{0}'，值 '{1}' 不是有效的 '{2}' 类型。</value>
    <comment>缓冲池选项无效。</comment>
  </data>
  <data name="InvalidCacheOptions" xml:space="preserve">
    <value>在缓冲池类型 '{0}' 中找不到与选项匹配的构造函数。</value>
    <comment>缓冲池选项无效。</comment>
  </data>
  <data name="InvalidCacheType" xml:space="preserve">
    <value>无效的缓冲池类型 '{0}'。</value>
    <comment>缓冲池类型无效。</comment>
  </data>
  <data name="InvalidCacheType_CreateInstance" xml:space="preserve">
    <value>创建缓冲池类型 '{0}' 的实例错误。</value>
    <comment>缓冲池类型无效创建实例异常。</comment>
  </data>
  <data name="InvalidCacheType_ICache" xml:space="preserve">
    <value>无效的缓冲池类型 '{0}'，没有实现 ICache&lt;TKey, TValue&gt; 接口。</value>
    <comment>缓冲池类型无效-未实现 ICache 接口。</comment>
  </data>
  <data name="InvalidOffsetLength" xml:space="preserve">
    <value>偏移量和长度超出数组的界限，或者计数大于从索引到源集合结尾处的元素数量。</value>
    <comment>偏移量和长度超出界限。</comment>
  </data>
  <data name="KeyDuplicate" xml:space="preserve">
    <value>已添加了具有相同键的项。</value>
    <comment>键重复。</comment>
  </data>
  <data name="KeyNotFound" xml:space="preserve">
    <value>指定的键 '{0}' 不存在。</value>
    <comment>指定的键不存在。</comment>
  </data>
  <data name="MustBeDelegate" xml:space="preserve">
    <value>类型必须从委托派生。</value>
    <comment>类型必须从委托派生。</comment>
  </data>
  <data name="MustBeEnum" xml:space="preserve">
    <value>提供的类型 '{0}' 必须是 Enum。</value>
    <comment>必须是枚举。</comment>
  </data>
  <data name="MustContainEnumInfo" xml:space="preserve">
    <value>要在此字符串中进行分析，必须指定有效信息。</value>
    <comment>必须包含枚举信息。</comment>
  </data>
  <data name="NoParsibleDigits" xml:space="preserve">
    <value>未能找到任何可识别的数字。</value>
    <comment>未能找到任何可识别的数字。</comment>
  </data>
  <data name="NotGenericMethodDefinition" xml:space="preserve">
    <value>{0} 不是 GenericMethodDefinition。只能对 MethodBase.IsGenericMethodDefinition 为 True 的方法调用 {1}。</value>
    <comment>不表示泛型方法定义。</comment>
  </data>
  <data name="ObjectDisposed" xml:space="preserve">
    <value>已释放该对象。</value>
    <comment>对象已释放资源。</comment>
  </data>
  <data name="OverflowByte" xml:space="preserve">
    <value>值对于 Byte 太大或太小。</value>
    <comment>值对于 Byte 太大或太小。</comment>
  </data>
  <data name="OverflowInt16" xml:space="preserve">
    <value>值对于 Int16 太大或太小。</value>
    <comment>值对于 Int16 太大或太小。</comment>
  </data>
  <data name="OverflowInt32" xml:space="preserve">
    <value>值对于 Int32 太大或太小。</value>
    <comment>值对于 Int32 太大或太小。</comment>
  </data>
  <data name="OverflowInt64" xml:space="preserve">
    <value>值对于 Int64 太大或太小。</value>
    <comment>值对于 Int64 太大或太小。</comment>
  </data>
  <data name="OverflowSByte" xml:space="preserve">
    <value>值对于 SByte 太大或太小。</value>
    <comment>值对于 SByte 太大或太小。</comment>
  </data>
  <data name="OverflowUInt16" xml:space="preserve">
    <value>值对于 UInt16 太大或太小。</value>
    <comment>值对于 UInt16 太大或太小。</comment>
  </data>
  <data name="OverflowUInt32" xml:space="preserve">
    <value>值对于 UInt32 太大或太小。</value>
    <comment>值对于 UInt32 太大或太小。</comment>
  </data>
  <data name="OverflowUInt64" xml:space="preserve">
    <value>值对于 UInt64 太大或太小。</value>
    <comment>值对于 UInt64 太大或太小。</comment>
  </data>
  <data name="ReadOnlyCollection" xml:space="preserve">
    <value>集合是只读的。</value>
    <comment>集合是只读的。</comment>
  </data>
  <data name="ReversedArgument" xml:space="preserve">
    <value>参数 '{0}' 和 '{1}' 的顺序颠倒。</value>
    <comment>参数顺序颠倒。</comment>
  </data>
  <data name="SameParameterName" xml:space="preserve">
    <value>两个参数的名称不能是相同的。</value>
    <comment>参数名相同。</comment>
  </data>
  <data name="SourceReaderClosed" xml:space="preserve">
    <value>无法从已关闭的 SourceReader 中读取。</value>
    <comment>不能从关闭的 SourceReader 中读取。</comment>
  </data>
  <data name="UnboundGenParam" xml:space="preserve">
    <value>不能对 ContainsGenericParameters 为 True 的类型或方法执行后期绑定操作。</value>
    <comment>不能是开放式泛型类型。</comment>
  </data>
</root>